import os
from pathlib import Path
import fitz  # PyMuPDF
from openai import OpenAI
import json
from typing import List, Dict
import requests
from io import BytesIO
import tempfile
import base64

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def download_pdf(url: str) -> BytesIO:
    response = requests.get(url)
    return BytesIO(response.content)

def extract_text_and_images_from_pdf_url(url: str) -> tuple[str, List[Dict]]:
    pdf_content = download_pdf(url)
    images = []
    
    with tempfile.NamedTemporaryFile(suffix=".pdf") as temp_file:
        temp_file.write(pdf_content.getvalue())
        temp_file.flush()
        doc = fitz.open(temp_file.name)
        text = ""
        
        for page_num, page in enumerate(doc):
            text += page.get_text()
            
            # Extract images
            image_list = page.get_images()
            for img_index, img in enumerate(image_list):
                xref = img[0]
                base_image = doc.extract_image(xref)
                image_data = base_image["image"]
                
                # Convert image to base64 for storage
                image_b64 = base64.b64encode(image_data).decode('utf-8')
                
                # Store image with position information
                image_info = {
                    "page": page_num + 1,
                    "index": img_index,
                    "data": image_b64,
                    "format": base_image["ext"],
                    # Add position markers from the text to match images with questions
                    "position_marker": f"[Image {page_num + 1}.{img_index + 1}]"
                }
                images.append(image_info)
                
                # Insert a marker in the text to indicate image position
                text += f"\n[Image {page_num + 1}.{img_index + 1}]\n"
                
    return text, images

def generate_solution(question: str, correct_answer: str, subject: str) -> str:
    prompt = f"""
    Generate a detailed solution for this {subject} olympiad question.
    
    Question: {question}
    Correct Answer: {correct_answer}
    
    Please provide a step-by-step solution that:
    1. Explains the approach
    2. Shows the key concepts involved
    3. Walks through the reasoning to reach the correct answer
    4. Notes that this is an AI-generated solution
    
    Format the solution clearly with steps and explanations.
    """
    
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant that generates detailed solutions for olympiad problems."},
            {"role": "user", "content": prompt}
        ]
    )
    
    return response.choices[0].message.content + "\n\nNote: This solution was generated by AI and should be verified by subject matter experts."

def parse_questions_by_subject(text: str, images: List[Dict], subject: str, answer_text: str = None, solution_text: str = None) -> List[Dict]:
    subject_prompts = {
        "chemistry": """
            Parse this chemistry olympiad exam. Preserve all chemical formulas and mathematical notation.
            Format each question as:
            1. Question content with LaTeX notation (e.g., H₂O, CO₂, ∫, Σ)
            2. Answer choices (can be text or [Image X.Y] references)
            3. Correct answer
        """,
        "mathematics": """
            Parse this mathematics olympiad exam. Preserve all mathematical notation.
            Format each question as:
            1. Question content with LaTeX notation (e.g., ∫, ∂, θ, π)
            2. Answer choices (can be text or [Image X.Y] references)
            3. Correct answer
        """
    }

    prompt = f"""
    {subject_prompts.get(subject, "Parse this olympiad exam.")}
    
    Return data in this format:
    {{
        "questions": [
            {{
                "content": "question text with LaTeX notation and [Image X.Y] markers",
                "choices": [
                    {{ "type": "text", "content": "A) LaTeX notation here" }},
                    {{ "type": "image", "imageRef": "X.Y" }}
                ],
                "correctAnswer": "A",
                "difficulty": "Medium",
                "category": "topic"
            }}
        ]
    }}
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant that parses olympiad questions into structured data."},
            {"role": "user", "content": prompt}
        ]
    )

    try:
        questions = json.loads(response.choices[0].message.content)["questions"]
        
        # Process each question
        for question in questions:
            # Match images with questions
            question_images = []
            for img in images:
                if img["position_marker"] in question["content"]:
                    question_images.append(img)
            question["images"] = question_images
            
            # Generate solution if none exists
            if not question.get("solution"):
                question["solution"] = generate_solution(
                    question["content"],
                    question["correctAnswer"],
                    subject
                )
        
        return questions
    except json.JSONDecodeError:
        print(f"Error parsing response for {subject}")
        return []

def main():
    subject_pdfs = {
        "mathematics": {
            "questions": ["url_to_math_questions_1"],
            "answers": ["url_to_math_answers_1"],
            "solutions": ["url_to_math_solutions_1"]  # Optional
        },
        "chemistry": {
            "questions": ["url_to_chem_questions_1"],
            "answers": None,  # Answers in same file
            "solutions": ["url_to_chem_solutions_1"]
        },
        # Add other subjects...
    }

    all_questions = []

    for subject, urls in subject_pdfs.items():
        print(f"Processing {subject}...")
        
        for i, question_url in enumerate(urls["questions"]):
            question_text, question_images = extract_text_and_images_from_pdf_url(question_url)
            
            # Handle answer and solution texts
            answer_text = None
            if urls.get("answers"):
                answer_text, _ = extract_text_and_images_from_pdf_url(urls["answers"][i])
            
            solution_text = None
            if urls.get("solutions"):
                solution_text, _ = extract_text_and_images_from_pdf_url(urls["solutions"][i])
            
            questions = parse_questions_by_subject(
                question_text,
                question_images,
                subject,
                answer_text,
                solution_text
            )
            
            for q in questions:
                q["subject"] = subject
            
            all_questions.extend(questions)

    with open("parsed_questions.json", "w") as f:
        json.dump({"questions": all_questions}, f, indent=2)

if __name__ == "__main__":
    main() 